% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/crashCountsGDB.R
\name{crashCounts.seg.gdb}
\alias{crashCounts.seg.gdb}
\title{Merge and Aggregate Crash Data by Road Segments using GPS Data - Spatial Roadway Files}
\usage{
crashCounts.seg.gdb(
  road_segments,
  crashes,
  crash_lat,
  crash_long,
  road_id_vars = NULL,
  road_geom = NULL,
  crash_coords = NULL,
  conditions = NULL,
  countvarname = "Total_Crashes",
  dist_feet = 50,
  dist_meters = NULL,
  crashRoute = NULL,
  roadRoute = NULL,
  projection_input = 4326,
  projection_working = NULL
)
}
\arguments{
\item{road_segments}{A data frame or `sf` object containing road segment data.
Expected fields include segment identifiers specified by `road_id_vars`, as
well as the geometry of the segments. If not already an `sf` object,
the function will attempt to create one using the provided geometry column.}

\item{crashes}{A data frame containing crash data. Expected fields include
crash locations specified by latitude and longitude.}

\item{crash_lat}{The name of the variable for the crash latitude.}

\item{crash_long}{The name of the variable for the crash longitude.}

\item{road_id_vars}{Optional. A character vector specifying the column names
that uniquely identify each road segment. If `NULL` (default), a new
identifier will be created.}

\item{road_geom}{Optional. A string specifying the name of the geometry column
in `road_segments`. If this is used, it should be of class `sfc_LINESTRING`
or `sfc_MULTILINESTRING`.}

\item{crash_coords}{Optional. A string specifying the name of the variable
with the GPS coordinates for the crashes. If this is used, it will override
`crash_lat` and `crash_long`. The variable should be of class `sfc_POINT`.}

\item{conditions}{Optional. A condition or set of conditions for filtering
the crashes data frame before aggregation. This can be specified as a
character string (e.g., `"Severity > 2"`), an expression (e.g.,
`expression(Severity > 2)`), or a list of expressions (e.g.,
`list(expression(Severity > 2), expression(Time < 6 | Time > 18))`).
If `NULL` (default), no additional conditions are applied.}

\item{countvarname}{Optional. A string specifying the name of the new variable
with the crash counts. The default is `"Total_Crashes"` but should be
specified by the user if any conditions are provided.}

\item{dist_feet}{Optional. A numeric value specifying the distance threshold
(in feet). Either `dist_feet` or `dist_meters` should be used. The default
is `dist_feet = 50`.}

\item{dist_meters}{Optional. A numeric value specifying the distance
threshold (in meters). If this is used, it overrides `dist_feet`.}

\item{crashRoute}{Optional. The name of the route ID variable in the crash
data frame to match the road segments on. If this is provided along with
`roadRoute`, crashes will be assigned only to road segments where
the crash's route ID matches the segment's route ID.}

\item{roadRoute}{Optional. The name of the route ID variable in the
`road_segments` data frame. This column should contain the route IDs
associated with each road segment.}

\item{projection_input}{Optional. A character string or numeric value specifying
the CRS (Coordinate Reference System) of the input data. Defaults to 4326
(WGS84 latitude/longitude). If the data frames are spatial objects, this will be extracted.}

\item{projection_working}{Optional. A character string or numeric value specifying
the CRS to which data will be transformed for accurate distance calculations.
Defaults to `NULL` which skips the transformation.}
}
\value{
A data frame with the original road segment data and a new variable that
  contains the crash counts for the specified conditions (if any).
}
\description{
This function merges a road segments dataset with a crash dataset based on
GPS locations and distances. It aggregates crash data per road segment,
assigning each crash to the nearest segment within a specified buffer
distance. Optional conditions can filter crashes based on various attributes.
Additionally, crashes are assigned to segments only if the crash's route ID
matches the segment's route ID, if such information is provided.
}
\examples{

# Sample road segments data with route IDs
library(sf)
road_segments_df <- data.frame(
  segment_id = 1:3,
  route_id = c("Route66", "I-5", "I-10")
)
# Create simple lines for the example
road_segments_df$geometry <- st_sfc(
  st_linestring(rbind(c(-118.25, 34.05), c(-118.24, 34.05))),
  st_linestring(rbind(c(-118.24, 34.05), c(-118.24, 34.06))),
  st_linestring(rbind(c(-118.24, 34.06), c(-118.23, 34.06)))
)
road_segments_sf <- st_sf(road_segments_df, crs = 4326)

# Sample crash data with route IDs
crashes_df <- data.frame(
  crash_id = 1:5,
  crash_latitude = c(34.0505, 34.055, 34.065, 34.051, 34.062),
  crash_longitude = c(-118.245, -118.242, -118.235, -118.243, -118.238),
  Severity = c(1, 3, 2, 5, 4),
  Time = c(2, 15, 20, 5, 23),
  route_id = c("Route66", "I-5", "I-10", "I-5", "Route66")
)

# Run the function
result <- crashCounts.seg.gdb(
  road_segments = road_segments_sf,
  crashes = crashes_df,
  crash_lat = "crash_latitude",
  crash_long = "crash_longitude",
  road_id_vars = c("segment_id"),
  crashRoute = "route_id",
  roadRoute = "route_id",
  dist_feet = 75,
  projection_input = 4326,
  projection_working = 3857
)

# View the result
print(result)

}
